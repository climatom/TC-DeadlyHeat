"""
This script iterates over all TCs and extracts the points at which there is 
a strong TC over land. 

More specifically, for each TC, it: 
    
    - Finds/writes the WFDEI lon/lat of the nearest land grid point. Note that 
    there may be more than one grid point for any TC (the storm can travel over
    land)
    
    - Finds/writes the TC lon/lat and distance to WFDEI grid point (listed above)
    
Output: txt file with... storm ID | time | WDFEI | lon | WFDEI lat | WFDEI lon 
| TC lat | TC lon | Distance 

"""
import GeneralFunctions as GF
import TC_Utils as tc
import numpy as np
from netCDF4 import Dataset

# ============================================================================#
#                           Script parameters                                 #
# ============================================================================#

# Input (TC) file. This was generated by applying "tc.nc2text_pres" to the raw 
# IBTrACS data. 
# Format is:
# [0] ID; [1] Year [2] jd.dayfrac; [3] Lon; [4] Lat; [5] Wind (kts); [6] Press
# [7] Dist to land
tcFile=\
"/media/gytm3/WD12TB/TropicalCyclones/TC-DeadlyHeat/Data/Hurricanes_press.txt"

# Input (WFDEI) file. This is a template that we'll use to take the WFDEI grid
# parameters from 
hifile="/media/gytm3/WD12TB/WATCH3H/Daily/c_HI_1979.nc"

# central pressure to be a "major" TC. 
pthresh=945 

# earliest year to use for TCs 
yr_st=1979 

# ============================================================================#
#                                   MAIN                                      #
# ============================================================================#

# Load the TC data
tcdata=np.loadtxt(tcFile)

# Load in a WFDEI file to get grid details
hif=Dataset(hifile,"r")
lon=hif.variables["lon"][:].data
lat=hif.variables["lat"][:].data
lon2,lat2=np.meshgrid(lon[:],lat[:])
ref_pos=np.column_stack((lon2.flatten(),lat2.flatten()))
msk=hif.variables["hi"][0,:,:].mask


# Change negative pressure/wind to NaN
idx=np.logical_or(tcdata[:,-2]<0,tcdata[:,-3]<0)
tcdata[idx]=np.nan

# Filter based on landfall, pressure, and year. 
idx=np.logical_and(tcdata[:,-1]==0,\
                   np.logical_and(tcdata[:,1]>=yr_st,tcdata[:,-2]<=pthresh))
tcsub=tcdata[idx,:]

# For each landfall location, find the nearest row/column in the WFDEI data
# Note that "match_meta" returns comprehensive data about the distance between
# the respective WFDEI grid points and the TC landfall locations. 
match_meta,rows,cols=tc.get_rc_mask_dist(tcsub[:,3],tcsub[:,4],lon2,lat2,msk)

# Loop over the tcsub and write out the id, position, and time. Ensure 
# that if a TC sits in the same place for more than one time, only the *initial*
# landfall time is taken. 
ids=np.unique(tcsub[:,0])
out=np.zeros((len(tcsub),4))*np.nan
for ii in ids:
    temp=tcsub[tcsub[:,0]==ii,:]
    # Loop over times that each TC was over land. Append locations to the 
    # output if not already present
    scratch=np.zeros((len(temp)))
    for jj in range(temp.shape[0]):
        
    

