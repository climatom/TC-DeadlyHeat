"""
This script iterates over all TCs and extracts the points at which there is 
a strong TC over land. 

More specifically, for each TC, it: 
    
    - Finds/writes the WFDEI lon/lat of the nearest land grid point. Note that 
    there may be more than one grid point for any TC (the storm can travel over
    land)
    
    - Finds/writes the TC lon/lat and distance to WFDEI grid point (listed above)
    
Output: txt file with... storm ID | time | WDFEI | lon | WFDEI lat | WFDEI lon 
| TC lat | TC lon | Distance 

"""
import GeneralFunctions as GF
import TC_Utils as tc
import numpy as np
from netCDF4 import Dataset

# ============================================================================#
#                           Script parameters                                 #
# ============================================================================#

# Input (TC) file. This was generated by applying "tc.nc2text_pres" to the raw 
# IBTrACS data. 
# Format is:
# [0] ID; [1] Year [2] jd.dayfrac; [3] Lon; [4] Lat; [5] Wind (kts); [6] Press
# [7] Dist to land
tcFile=\
"/media/gytm3/WD12TB/TropicalCyclones/TC-DeadlyHeat/Data/Hurricanes_press.txt"

# Input (WFDEI) file. This is a template that we'll use to take the WFDEI grid
# parameters from 
hifile="/media/gytm3/WD12TB/WATCH3H/Daily/c_HI_1979.nc"

# central pressure to be a "major" TC. 
pthresh=945 

# earliest year to use for TCs 
yr_st=1979 

# ============================================================================#
#                                   MAIN                                      #
# ============================================================================#

# Load the TC data
tcdata=np.loadtxt(tcFile)

# Load in a WFDEI file to get grid details
hif=Dataset(hifile,"r")
lon=hif.variables["lon"][:].data
lat=hif.variables["lat"][:].data
lon2,lat2=np.meshgrid(lon[:],lat[:])
ref_pos=np.column_stack((lon2.flatten(),lat2.flatten()))
msk=hif.variables["hi"][0,:,:].mask


# Change negative pressure/wind to NaN
idx=np.logical_or(tcdata[:,-2]<0,tcdata[:,-3]<0)
tcdata[idx]=np.nan

# Filter based on landfall, pressure, and year. 
idx=np.logical_and(tcdata[:,-1]==0,\
                   np.logical_and(tcdata[:,1]>=yr_st,tcdata[:,-2]<=pthresh))
tcsub=tcdata[idx,:]

# For each landfall location, find the nearest row/column in the WFDEI data
# Note that "match_meta" returns comprehensive data about the distance between
# the respective WFDEI grid points and the TC landfall locations. It also 
# returns, in the final column, a unique identifying index for the location. 
# We can use this to ensure that, when a TC makes landfall, we only take the 
# *initial* landfall time as the reference time 
match_meta,rows,cols=tc.get_rc_mask_dist(tcsub[:,3],tcsub[:,4],lon2,lat2,msk)

# Loop over the tcsub and write out the id, position, and time... 
ids=np.unique(tcsub[:,0])
out=np.zeros((len(tcsub),10))*np.nan
count=0
for ii in ids:
    temp=match_meta[tcsub[:,0]==ii,:]; time_temp=tcsub[tcsub[:,0]==ii,1:3]
    locs=[]
    for jj in range(len(temp)):
        if temp[jj,-1] not in locs:                    
            out[count,0]=ii # id
            out[count,1]=time_temp[jj,0] # year
            out[count,2]=time_temp[jj,1] # jd.frac
            out[count,3]=temp[jj,0] # lat
            out[count,4]=temp[jj,1] # lon
            out[count,5]=temp[jj,2] # grid lat (WFDEI)
            out[count,6]=temp[jj,3] # grid lon (WFDEI)
            out[count,7]=temp[jj,4] # grid row (WFDEI)
            out[count,8]=temp[jj,5] # grid col (WFDEI)
            out[count,9]=temp[jj,6] # dist between landfall and WFDEI grid point
            # Store location so we can guard against double counting
            locs.append(temp[jj,-1])
            count+=1
out=out[:count,:]

# ==========#
# Write out
# ==========#

# Out name
fout="/media/gytm3/WD12TB/TropicalCyclones/TC-DeadlyHeat/Data/LandFall.txt"
# Header
header="ID\tYEAR\tJD.JD\tLAT\tLON\tGLAT\tGLON\tROW\tCOL\tDIST"
# Write it
np.savetxt(fout,out,delimiter="\t",header=header,comments="",fmt="%.3f")

    

